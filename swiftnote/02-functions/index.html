<!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Chapter 02 Functions</title><header><!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Chapter 02 Functions | Coding With Matt</title><link rel=stylesheet href=/css/fonts.css><link rel=stylesheet href=/css/style.css></head><body><nav><ul class=menu><li><a href=/>Home</a></li><li><a href=/post/>Posts</a></li><li><a href=/swiftnote/>Swift</a></li><li><a href=/draw/>Draw</a></li></ul><hr></nav></header></head><body><main><article class=project><h1>Chapter 02 Functions</h1>Contents<nav id=TableOfContents><ul><li><a href=#chapter-2--functions-part-1>Chapter 2 — Functions (Part 1)</a><ul><li><a href=#function-parameters-and-return-value>Function Parameters and Return Value</a></li><li><a href=#void-return-type-and-parameters>Void Return Type and Parameters</a></li><li><a href=#function-signature>Function Signature</a></li><li><a href=#external-parameter-names>External Parameter Names</a></li><li><a href=#overloading>Overloading</a></li><li><a href=#default-parameter-values>Default Parameter Values</a></li><li><a href=#variadic-parameters>Variadic Parameters</a></li><li><a href=#initializers-are-functions>Initializers Are Functions</a></li><li><a href=#mini-project>Mini Project</a></li><li><a href=#modifiable-parameters>Modifiable Parameters</a></li></ul></li></ul></nav><p class=summary>Functions are first class citizens</p><section class=content><h1 id=chapter-2--functions-part-1>Chapter 2 — Functions (Part 1)</h1><hr><h2 id=function-parameters-and-return-value>Function Parameters and Return Value</h2><h3 id=summary>Summary</h3><ul><li>A function declares <strong>inputs</strong> (parameters) and an <strong>output</strong> (return type): <code>func name(_ a: Int, _ b: Int) -> Int { ... }</code>.</li><li>Parameter names become <strong>local variables</strong> inside the function; they’re <strong>scoped</strong> to the function body.</li><li><code>return</code> both <strong>produces</strong> the value and <strong>stops</strong> execution; its value’s type must match the declared return type.</li><li>A <strong>call</strong> uses the function name plus parentheses and arguments: <code>sum(4, 5)</code>. Argument variable names outside do <strong>not</strong> carry inside.</li><li>You can <strong>ignore</strong> a result (compiler warns) or silence it with <code>_ = ...</code> or mark the function <code>@discardableResult</code>.</li><li>Calls can be <strong>nested</strong>: <code>sum(4, sum(5, 6))</code>.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sum</span>(<span style=color:#66d9ef>_</span> x: Int, <span style=color:#66d9ef>_</span> y: Int) -&gt; Int {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> result = x <span style=color:#f92672>+</span> y
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> result
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> z = sum(<span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>)                 <span style=color:#75715e>// 9</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> w = sum(<span style=color:#ae81ff>4</span>, sum(<span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>))         <span style=color:#75715e>// 15</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>_</span> = sum(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>)                     <span style=color:#75715e>// deliberately ignore result</span>
</span></span></code></pre></div><h3 id=free-response-leave-space-to-write>Free-Response (leave space to write)</h3><ol><li><p>In your own words, what are <strong>parameters</strong> and a <strong>return type</strong>? How do they act like a contract for the function?</p></li><li><p>What does <code>return</code> do besides give back a value? Why must its value’s type match the declared return type?</p></li><li><p>Why do <code>x</code> and <code>y</code> inside <code>sum</code> not refer to variables named <code>x</code> and <code>y</code> outside the function?</p></li><li><p>Show a legal call to <code>sum</code> and a call that <strong>won’t</strong> compile. Explain why the second fails.</p></li></ol><h3 id=programming-exercises>Programming Exercises</h3><ul><li><strong>E1 (starter):</strong> Write <code>func steepTime(_ grams: Int, _ tempC: Int) -> Int</code> that returns minutes. Rule of thumb: <code>return max(1, min(5, grams / 3 + (tempC >= 90 ? 1 : 0)))</code>. Call it with <code>(6, 95)</code> and <code>(3, 80)</code>.</li><li><strong>E2 (from scratch):</strong> Write <code>func addThree(_ a: Int, _ b: Int, _ c: Int) -> Int</code> and test <code>addThree(1, 2, 3)</code>. Then nest a call: <code>addThree(addThree(1,1,1), 2, 3)</code>.</li></ul><hr><h2 id=void-return-type-and-parameters>Void Return Type and Parameters</h2><h3 id=summary-1>Summary</h3><ul><li>A function may return <strong>nothing</strong>: write <code>-> Void</code>, <code>-> ()</code>, <strong>or omit</strong> the return type entirely.</li><li>A function may take <strong>no parameters</strong>: keep the empty parentheses in both declaration and call.</li><li>A function can have <strong>neither</strong> parameters nor a return value.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>say1</span>(<span style=color:#66d9ef>_</span> s: String) -&gt; Void { print(s) }
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>say2</span>(<span style=color:#66d9ef>_</span> s: String) -&gt; ()   { print(s) }
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>say3</span>(<span style=color:#66d9ef>_</span> s: String)         { print(s) }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>greet</span>() -&gt; String { <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;howdy&#34;</span> }
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> g = greet()        <span style=color:#75715e>// note the parentheses: greet()</span>
</span></span></code></pre></div><h3 id=free-response>Free-Response</h3><ol><li><p>When would you choose a function that returns <strong>Void</strong> vs one that returns a value?</p></li><li><p>Why must you still write <code>()</code> when calling a parameterless function?</p></li></ol><h3 id=programming-exercises-1>Programming Exercises</h3><ul><li><strong>E3 (starter):</strong> <code>func logBrew(_ message: String)</code> prints <code>"☕️ " + message</code>. Call it three times.</li><li><strong>E4 (from scratch):</strong> <code>func ping()</code> prints <code>"ping"</code> and returns nothing. Call it twice.</li></ul><hr><h2 id=function-signature>Function Signature</h2><h3 id=summary-2>Summary</h3><ul><li>A function’s <strong>type</strong> is its <strong>signature</strong>: <code>(Int, Int) -> Int</code> describes “takes two <code>Int</code>, returns an <code>Int</code>”.</li><li>Empty forms are <code>() -> Void</code> or <code>() -> ()</code>.</li><li>Because functions have types, you can <strong>store them in variables</strong> and <strong>pass them around</strong>.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sum</span>(<span style=color:#66d9ef>_</span> a: Int, <span style=color:#66d9ef>_</span> b: Int) -&gt; Int { a <span style=color:#f92672>+</span> b }
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> f: (Int, Int) -&gt; Int = sum
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> result = f(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>)  <span style=color:#75715e>// 5</span>
</span></span></code></pre></div><h3 id=free-response-1>Free-Response</h3><ol><li>What is a <strong>function signature</strong>, and why is it useful?</li></ol><h3 id=programming-exercises-2>Programming Exercises</h3><ul><li><strong>E5 (starter):</strong> Declare <code>var combine: (Int, Int) -> Int = sum</code>. Reassign it to a new function <code>func mul(_ a:Int,_ b:Int)->Int { a*b }</code> and call <code>combine(3,4)</code> before/after reassignment.</li><li><strong>E6 (from scratch):</strong> Write <code>func minus(_ a:Int,_ b:Int)->Int</code> and store it in <code>let op: (Int,Int)->Int</code>. Call <code>op(10, 7)</code>.</li></ul><hr><h2 id=external-parameter-names>External Parameter Names</h2><h3 id=summary-3>Summary</h3><ul><li><strong>By default</strong>, parameter names are <strong>external</strong> and used as <strong>labels</strong> at the call site.</li><li>Change the external name by <strong>writing it before</strong> the internal name; <strong>suppress</strong> it with <code>_</code>.</li><li>Labels help readability but <strong>do not</strong> let you reorder arguments.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>echo</span>(string s: String, times n: Int) -&gt; String {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> out = <span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#66d9ef>_</span> <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>1.</span>..n { out <span style=color:#f92672>+=</span> s }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> out
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> a = echo(string: <span style=color:#e6db74>&#34;hi&#34;</span>, times: <span style=color:#ae81ff>3</span>)   <span style=color:#75715e>// labels required</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>multiply</span>(<span style=color:#66d9ef>_</span> x: Int, <span style=color:#66d9ef>_</span> y: Int) -&gt; Int { x <span style=color:#f92672>*</span> y } <span style=color:#75715e>// labels suppressed</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> b = multiply(<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>)
</span></span></code></pre></div><h3 id=free-response-2>Free-Response</h3><ol><li><p>What’s the difference between <strong>external</strong> and <strong>internal</strong> parameter names?</p></li><li><p>When might you <strong>suppress</strong> labels with <code>_</code>?</p></li></ol><h3 id=programming-exercises-3>Programming Exercises</h3><ul><li><strong>E7 (starter):</strong> Implement <code>func card(for work: String, by composer: String) -> String</code> so <code>card(for: "Goldberg Variations", by: "Bach")</code> returns <code>"Bach — Goldberg Variations"</code>.</li><li><strong>E8 (from scratch):</strong> Write <code>func brew(tea name: String, at tempC: Int)</code> that prints a sentence. Call it using labels.</li></ul><hr><h2 id=overloading>Overloading</h2><h3 id=summary-4>Summary</h3><ul><li>You may define multiple functions with the <strong>same name</strong> if their <strong>signatures differ</strong> (parameter types/arity or return type with clear context).</li><li>If two overloads differ <strong>only by return type</strong>, the <strong>context must disambiguate</strong> (type annotation or using the result where a specific type is expected).</li><li>You can also disambiguate with <strong><code>as</code></strong> plus the function type.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>say</span>(<span style=color:#66d9ef>_</span> what: String) { print(what) }
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>say</span>(<span style=color:#66d9ef>_</span> what: Int)    { print(what) }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>say</span>() -&gt; String { <span style=color:#e6db74>&#34;one&#34;</span> }
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>say</span>() -&gt; Int    { <span style=color:#ae81ff>1</span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> s: String = say()                 <span style=color:#75715e>// picks String version</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> i = (say <span style=color:#66d9ef>as</span> () -&gt; Int)()          <span style=color:#75715e>// calls Int version</span>
</span></span></code></pre></div><h3 id=free-response-3>Free-Response</h3><ol><li><p>What is <strong>overloading</strong>?</p></li><li><p>Why is <code>let x = say()</code> ambiguous above? Show two ways to fix it?</p></li></ol><h3 id=programming-exercises-4>Programming Exercises</h3><ul><li><strong>E9 (starter):</strong> Overload <code>describe</code> so <code>describe(42)</code> returns <code>"number 42"</code> and <code>describe("Bach")</code> returns <code>"composer Bach"</code>. Print both.</li><li><strong>E10 (from scratch):</strong> Create two <code>score(of:)</code> overloads: one that takes a <code>String</code> (returns <code>"Theme: &lt;name>"</code>), one that takes an <code>Int</code> (returns <code>"Movement \(n)"</code>). Call both.</li></ul><hr><h2 id=default-parameter-values>Default Parameter Values</h2><h3 id=summary-5>Summary</h3><ul><li>Give a <strong>default</strong> with <code>=</code> in the declaration; callers may <strong>omit</strong> that argument.</li><li>Defaults effectively create <strong>multiple ways</strong> to call the same function.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>brew</span>(<span style=color:#66d9ef>_</span> tea: String, at tempC: Int = <span style=color:#ae81ff>90</span>) {
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;Brewing </span><span style=color:#e6db74>\(</span>tea<span style=color:#e6db74>)</span><span style=color:#e6db74> at </span><span style=color:#e6db74>\(</span>tempC<span style=color:#e6db74>)</span><span style=color:#e6db74>°C&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>brew(<span style=color:#e6db74>&#34;Oolong&#34;</span>)          <span style=color:#75715e>// uses 90</span>
</span></span><span style=display:flex><span>brew(<span style=color:#e6db74>&#34;Matcha&#34;</span>, at: <span style=color:#ae81ff>75</span>)  <span style=color:#75715e>// override</span>
</span></span></code></pre></div><h3 id=programming-exercises-5>Programming Exercises</h3><ul><li><strong>E11 (starter):</strong> <code>func repeatPrint(_ text: String, times: Int = 1)</code> prints <code>text</code> a total of <code>times</code> times, on one line separated by spaces. Hint is to look at how the print function works.</li></ul><hr><h2 id=variadic-parameters>Variadic Parameters</h2><h3 id=summary-6>Summary</h3><ul><li>Mark a parameter <strong>variadic</strong> with <code>...</code> to accept <strong>zero or more</strong> values; inside, it’s an <strong>array</strong>.</li><li>Other parameters may follow; the next one often needs an <strong>external label</strong> to show where the list ends.</li><li>Swift 5.4+ allows <strong>multiple variadics</strong> (adjacent second needs a label).</li><li><strong>No splat</strong>: you <strong>cannot</strong> pass an existing array as a variadic list directly; write an overload that takes <code>[T]</code> instead.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sum</span>(<span style=color:#66d9ef>_</span> nums: Int...) -&gt; Int {
</span></span><span style=display:flex><span>    nums.reduce(<span style=color:#ae81ff>0</span>, <span style=color:#f92672>+</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> s1 = sum(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>)   <span style=color:#75715e>// 10</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>&#34;Manny&#34;</span>, <span style=color:#e6db74>&#34;Moe&#34;</span>, separator: <span style=color:#e6db74>&#34;, &#34;</span>, terminator: <span style=color:#e6db74>&#34;, &#34;</span>)
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>&#34;Jack&#34;</span>)              <span style=color:#75715e>// Manny, Moe, Jack</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>playlist</span>(<span style=color:#66d9ef>_</span> works: String..., by composer: String) {
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>\(</span>composer<span style=color:#e6db74>)</span><span style=color:#e6db74>: </span><span style=color:#e6db74>\(</span>works.joined<span style=color:#e6db74>(</span>separator: <span style=color:#e6db74>&#34; | &#34;</span><span style=color:#e6db74>))</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>playlist(<span style=color:#e6db74>&#34;Prelude&#34;</span>, <span style=color:#e6db74>&#34;Fugue&#34;</span>, by: <span style=color:#e6db74>&#34;Bach&#34;</span>)
</span></span></code></pre></div><h3 id=free-response-4>Free-Response</h3><ol><li><p>What does it mean that a parameter is <strong>variadic</strong>? How is it seen inside the function?</p></li><li><p>Why can’t you pass an array directly to a variadic parameter? What’s a practical workaround?</p></li></ol><h3 id=programming-exercises-6>Programming Exercises</h3><ul><li><strong>E13 (starter):</strong> Write <code>func multiply(_ values: Int...) -> Int</code> that returns the product (empty input returns <code>1</code>). Test with <code>multiply(2,3,4)</code> and <code>multiply()</code>.</li><li><strong>E14 (from scratch):</strong> Overload <code>sum</code> with <code>func sum(_ nums: [Int]) -> Int</code> so you can call <code>sum([1,2,3])</code>.</li></ul><hr><h2 id=initializers-are-functions>Initializers Are Functions</h2><h3 id=summary-7>Summary</h3><ul><li>Calling <code>Type(...)</code> invokes an <strong>initializer</strong> — a special function that constructs an instance.</li><li>Initializers can have <strong>parameters</strong>, <strong>labels</strong>, <strong>defaults</strong>, and can be <strong>overloaded</strong>.</li><li>Standard types (e.g., <code>String</code>) provide many initializers.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>let</span> s1 = String(<span style=color:#ae81ff>42</span>)                          <span style=color:#75715e>// &#34;42&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> s2 = String(repeating: <span style=color:#e6db74>&#34;ho&#34;</span>, count: <span style=color:#ae81ff>2</span>)   <span style=color:#75715e>// &#34;hoho&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Tea</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> name: String
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> tempC: Int
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> eg = Tea(name: <span style=color:#e6db74>&#34;Earl Grey&#34;</span>, tempC: <span style=color:#ae81ff>95</span>)
</span></span></code></pre></div><h3 id=free-response-5>Free-Response</h3><ol><li><p>What does <code>String(42)</code> do? Why is that an initializer call?</p></li><li><p>Give an example of an initializer with <strong>labels</strong> that improves clarity?</p></li></ol><h3 id=programming-exercises-7>Programming Exercises</h3><ul><li><strong>E15 (starter):</strong> Define <code>struct Sonata { let key: String; init(_ key: String) { self.key = key } }</code>. Create <code>Sonata("C minor")</code>.</li><li><strong>E16 (from scratch):</strong> Add a second initializer <code>init(repeating motif: String, count: Int)</code> to build a <code>String</code> motif inside <code>Sonata</code> (store it as <code>let motif: String?</code>). Create one with <code>("la", 3)</code> → <code>"lalala"</code>.</li></ul><h2 id=mini-project>Mini Project</h2><p>Create the Dice Roller mini-project as a Markdown file and save it for download.</p><h3 id=overview>Overview</h3><p>Build a tiny library of functions to simulate common tabletop dice rolls (e.g., “roll 3d6 + 2”). You’ll practice <strong>parameters and return values</strong>, <strong>external labels</strong>, <strong>default values</strong>, <strong>overloading</strong>, <strong>variadic parameters</strong>, and <strong>function signatures</strong>. Keep it console-only and focused on functions—no UI.</p><h3 id=learning-goals>Learning goals</h3><ul><li>Parameters & return: <code>func rollDie(sides: Int) -> Int</code></li><li>External labels: <code>roll(count:sides:)</code>, <code>applyModifier(total:add:multiply:)</code></li><li>Defaults: <code>sides:</code> default to 6; <code>add:</code> default to 0; <code>multiply:</code> default to 1</li><li>Overloading: <code>roll(_ notation: String)</code> vs <code>roll(count:sides:)</code></li><li>Variadic: <code>sum(_ values: Int...)</code></li><li>Function signatures: potentially store a function in a variable for later use</li></ul><hr><h3 id=starter-outline-paste-into-mainswift>Starter outline (paste into <code>main.swift</code>)</h3><p>(Implement some; create others from scratch where noted.) See description of problems below</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>Foundation</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 1) Basic single-die roll (starter)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>rollDie</span>(sides: Int = <span style=color:#ae81ff>6</span>) -&gt; Int {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// </span><span style=color:#75715e>TODO:</span><span style=color:#75715e> return an Int between 1 and sides (inclusive).</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Guard against invalid sides (&lt; 2): if invalid, return 1.</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 2) Multiple dice (starter, uses external labels + default)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>roll</span>(count n: Int, sides s: Int = <span style=color:#ae81ff>6</span>) -&gt; [Int] {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// </span><span style=color:#75715e>TODO:</span><span style=color:#75715e> roll n dice of s sides each, return array of results.</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Guard: if n &lt; 1, return [].</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> []
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 3) Summation (from scratch, variadic)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Signature: func sum(_ values: Int...) -&gt; Int</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 4) Apply modifier (from scratch, defaults)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Signature: func applyModifier(total: Int, add: Int = 0, multiply: Int = 1) -&gt; Int</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 5) Overload roll to return a total directly (from scratch, overloading)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Signature: func roll(_ notation: String) -&gt; Int</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Minimal requirement: support &#34;NdS+K&#34; where N, S, K are positive Ints (K optional).</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Example: &#34;3d6+2&#34;, &#34;2d8&#34;, &#34;1d20+0&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// If parsing fails, return 0.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 6) Tiny demo (optional)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// print(rollDie())</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// print(roll(count: 3, sides: 6))</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// print(sum(1,2,3,4))</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// let total = applyModifier(total: 12, add: 2)    // 14</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// print(roll(&#34;3d6+2&#34;))</span>
</span></span></code></pre></div><hr><h3 id=tasks--requirements-with-api-hints>Tasks & requirements (with API hints)</h3><h3 id=1-rolldiesides>1) <code>rollDie(sides:)</code></h3><ul><li>Return a random Int in <code>1...sides</code>.</li><li>Default: <code>sides: 6</code>.</li><li>Guard invalid input (<code>sides &lt; 2</code> → return 1).</li></ul><p><strong>API hint:</strong> Use <code>Int.random(in: 1...sides)</code> and <code>guard sides >= 2 else { return 1 }</code>.</p><hr><h3 id=2-rollcountsides>2) <code>roll(count:sides:)</code></h3><ul><li>Return an array of <code>count</code> rolls using <code>rollDie(sides:)</code>.</li><li>Defaults: <code>sides</code> defaults to 6.</li><li>External labels must be used at call sites.</li><li>Guard: <code>count &lt; 1</code> → return <code>[]</code>.</li></ul><p><strong>API hint:</strong> Use ranges and mapping, e.g. <code>(0..&lt;n).map { _ in rollDie(sides: s) }</code>.</p><hr><h3 id=3-sum_-variadic>3) <code>sum(_:)</code> (variadic)</h3><ul><li>Implement <code>sum(_ values: Int...) -> Int</code>.</li><li>Empty input returns <code>0</code>.</li></ul><p><strong>API hint:</strong> <code>values.reduce(0, +)</code> is concise; or loop and accumulate into a <code>var total = 0</code>.</p><hr><h3 id=4-applymodifiertotaladdmultiply>4) <code>applyModifier(total:add:multiply:)</code></h3><ul><li>Return <code>(total + add) * multiply</code>.</li><li>Defaults: <code>add = 0</code>, <code>multiply = 1</code>.</li><li>Use external labels for readability.</li></ul><p><strong>API hint:</strong> Just arithmetic and defaults; consider <code>max</code>, <code>min</code> if you want to clamp results (optional).</p><hr><h3 id=5-roll_-notation-overloading>5) <code>roll(_ notation:)</code> (overloading)</h3><ul><li>Overload base name <code>roll</code> with a different signature: it takes a <code>String</code>.</li><li>Parse minimal dice notation: <code>NdS+K</code> (K optional).<ul><li>Examples: <code>"3d6+2"</code>, <code>"2d8"</code>, <code>"1d20+0"</code>.</li></ul></li><li>Use <code>roll(count:sides:)</code> and <code>sum(_:)</code>, then pass the total to <code>applyModifier</code>.</li><li>If parsing fails, return <code>0</code>.</li></ul><p><strong>API hints:</strong></p><ul><li>Split the string:<br><code>let parts = notation.split(separator: "d", maxSplits: 1)</code> → <code>N</code> and <code>"S+K"</code><br>Then <code>S+K</code> can be split by <code>"+"</code>: <code>let tail = tailPart.split(separator: "+", maxSplits: 1)</code><br>Convert pieces with <code>Int(String(...))</code>.</li><li>Validate with <code>guard let</code> for each integer; on failure, <code>return 0</code>.</li></ul><hr><h3 id=6-tiny-smoke-test-manual>6) Tiny smoke test (manual)</h3><p>Show at least three calls demonstrating labels, defaults, variadic, and overloading.</p><p><strong>API hint:</strong> Print results with <code>print(...)</code> and use optional binding if needed.</p><hr><h3 id=acceptance-checklist>Acceptance checklist</h3><ul><li>Uses <strong>external parameter names</strong> appropriately (e.g., <code>count:</code>, <code>sides:</code>, <code>add:</code>).</li><li>Employs <strong>default parameter values</strong> (e.g., <code>sides: 6</code>, <code>add: 0</code>, <code>multiply: 1</code>).</li><li>Demonstrates <strong>overloading</strong> with <code>roll(_ notation: String)</code>.</li><li>Includes a <strong>variadic</strong> function <code>sum(_:)</code>.</li><li>Input validation with clear fallbacks (no crashes on bad input).</li><li>Small, readable functions with clear names.</li></ul><hr><h3 id=hints--api-cheat-sheet>Hints & API cheat sheet</h3><ul><li>Random number: <code>Int.random(in: 1...s)</code></li><li>Ranges: <code>0..&lt;n</code>, <code>1...s</code></li><li>Collections: <code>.map</code>, <code>.reduce</code>, <code>.filter</code>, <code>.isEmpty</code></li><li>Parsing: <code>String.split(separator:)</code>, <code>Int(String)</code></li><li>Control flow: <code>guard</code>/<code>else</code>, <code>if</code>/<code>else</code>, <code>return 0</code> on failure</li><li>String building (optional): <code>joined(separator:)</code> for printing rolls</li></ul><hr><h3 id=stretch-goals-optional>Stretch goals (optional)</h3><ul><li>Add <code>"adv"</code> / <code>"dis"</code> suffix: <code>"2d20adv"</code> (roll twice, take higher) / <code>"2d20dis"</code> (take lower).</li><li>Support <code>"NdSxR"</code> exploding dice: each max roll adds a reroll once.</li><li>Add <code>printRolls: Bool = false</code> default param to display intermediate results.</li><li>Add <code>best(count:sides:keep:)</code> to keep the highest K dice from N rolls.</li></ul><hr><h3 id=reflection-questions-beginner>Reflection questions (beginner)</h3><ol><li>Where did you use <strong>external parameter names</strong> and why did they help readability?</li><li>Show one call that relies on a <strong>default parameter</strong>. What would the call look like without the default?</li><li>Explain how your <strong>overloaded</strong> <code>roll</code> functions differ by <strong>signature</strong>. Why can Swift tell them apart?</li><li>Why is <code>sum(_:)</code> a good candidate for a <strong>variadic</strong> parameter?</li><li>If you had to pass a function as a parameter later (e.g., a custom modifier), how would you write its <strong>signature</strong>?</li></ol><h2 id=modifiable-parameters>Modifiable Parameters</h2><h3 id=summary-8>Summary</h3><ul><li><p>Inside a function, each parameter acts like a <strong>local constant</strong> (<code>let</code>): you can <em>use</em> it, but you can’t assign a new value to it.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>say</span>(<span style=color:#66d9ef>_</span> s: String, times: Int, loudly: Bool) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// loudly = true   // ❌ error: cannot assign to parameter</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>If you want a <strong>working copy</strong> you can change, make a new local <code>var</code> and copy the parameter into it (you can even reuse the same name):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>say</span>(<span style=color:#66d9ef>_</span> s: String, times: Int, loudly: Bool) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> loudly = loudly   <span style=color:#75715e>// local shadow copy</span>
</span></span><span style=display:flex><span>    loudly = <span style=color:#66d9ef>true</span>         <span style=color:#75715e>// ✅ ok, this is the local var</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>Changing this local <code>var</code> <strong>does not</strong> change anything outside the function. It’s just a copy that lives inside the function body.</p></li><li><p>If you want a function to <strong>change the caller’s variable</strong>, you must:</p><ul><li>Mark the parameter as <code>inout</code> in the function declaration,</li><li>Pass a <strong><code>var</code></strong> from the caller,</li><li>Use <code>&</code> in front of the variable when you call the function.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>removeCharacter</span>(<span style=color:#66d9ef>_</span> c: Character, from s: <span style=color:#66d9ef>inout</span> String) -&gt; Int {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> howMany = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>let</span> ix = s.firstIndex(of: c) {
</span></span><span style=display:flex><span>        s.remove(at: ix)
</span></span><span style=display:flex><span>        howMany <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> howMany
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> word = <span style=color:#e6db74>&#34;hello&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> removed = removeCharacter(<span style=color:#e6db74>&#34;l&#34;</span>, from: &amp;word)
</span></span><span style=display:flex><span><span style=color:#75715e>// removed == 2, word == &#34;heo&#34;</span>
</span></span></code></pre></div></li><li><p>Using <code>inout</code> means the function is allowed to <strong>modify the caller’s storage</strong> as a side effect. Swift forces you to write <code>&</code> so you see the “danger” clearly.</p></li></ul><hr><h3 id=free-response-questions-leave-space-to-write>Free-Response Questions (leave space to write)</h3><ol><li><p>In your own words, why does Swift prevent you from assigning directly to a parameter inside a function?</p></li><li><p>What does it mean to “shadow” a parameter with a local <code>var</code>? How is the shadow different from the original parameter?</p></li><li><p>Look at this code:</p></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>trimCopy</span>(<span style=color:#66d9ef>_</span> text: String) -&gt; String {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> text = text
</span></span><span style=display:flex><span>    text = text.trimmingCharacters(<span style=color:#66d9ef>in</span>: .whitespaces)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> text
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> original = <span style=color:#e6db74>&#34; hello &#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> trimmed = trimCopy(original)
</span></span></code></pre></div><p>Explain why <code>original</code> keeps its spaces, even though <code>text</code> is changed inside the function.</p><ol start=4><li><p>Imagine you want a function that both <strong>changes</strong> a string by removing all <code>"a"</code> characters and <strong>returns</strong> how many <code>"a"</code> characters were removed. Why might <code>inout</code> be useful here, instead of only returning a new string?</p></li><li><p>When calling a function with an <code>inout</code> parameter, why does Swift require you to write <code>&amp;myVar</code> instead of just <code>myVar</code>?</p></li><li><p>Describe one situation where using <code>inout</code> is a <strong>good idea</strong>, and one situation where it would be <strong>unnecessary or confusing</strong>.</p></li></ol><hr><h3 id=drills-short-focused-tasks>Drills (short, focused tasks)</h3><ul><li><p><strong>D1 – Fix the compiler error (shadowing):</strong><br>The function below doesn’t compile. Rewrite it using a local <code>var</code> shadow so it compiles and behaves as intended.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>markExcited</span>(<span style=color:#66d9ef>_</span> message: String, excited: Bool) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// goal: always make excited true inside this function</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// excited = true   // ❌ error</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// print(message, excited)</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p><strong>D2 – Working copy vs original:</strong><br>Write a function <code>func trimmedCopy(_ text: String) -> String</code> that returns a version of <code>text</code> with leading and trailing spaces removed, without changing the caller’s variable. Then, in a comment, explain why the original string is unchanged.</p></li><li><p><strong>D3 – In your own words:</strong><br>In 2–3 sentences, explain the difference between:</p><ul><li><strong>Changing a parameter’s shadow copy</strong> inside the function, and</li><li><strong>Changing an <code>inout</code> parameter</strong> that belongs to the caller.</li></ul></li></ul><hr><h3 id=programming-exercises-8>Programming Exercises</h3><h4 id=e1--shadowing-a-parameter-starter>E1 — Shadowing a parameter (starter)</h4><p><strong>Goal:</strong> Practice creating a local <code>var</code> from a parameter.</p><p>Write a function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>shout</span>(<span style=color:#66d9ef>_</span> message: String, times: Int, loudly: Bool) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Requirements:</p><ul><li>Inside the function, create a local <code>var loudly = loudly</code>.</li><li>Set the local <code>loudly</code> to <code>true</code>.</li><li>If <code>loudly</code> is <code>true</code>, print <code>message.uppercased()</code> <code>times</code> times.</li><li>If <code>times</code> is less than 1, print nothing.</li></ul><p><strong>Hint (API):</strong><br>Use a <code>for _ in 1...times</code> loop and <code>message.uppercased()</code>.</p><hr><h4 id=e2--remove-a-character-in-place-with-inout-book-style-starter>E2 — Remove a character in place with <code>inout</code> (book-style, starter)</h4><p><strong>Goal:</strong> Use <code>inout</code> to change the caller’s <code>String</code> in place.</p><p>Implement:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>removeCharacter</span>(<span style=color:#66d9ef>_</span> c: Character, from s: <span style=color:#66d9ef>inout</span> String) -&gt; Int {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Requirements:</p><ul><li><p>Remove <strong>all</strong> occurrences of <code>c</code> from <code>s</code>.</p></li><li><p>Return how many characters were removed.</p></li><li><p>Test:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>var</span> word = <span style=color:#e6db74>&#34;hello&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> removed = removeCharacter(<span style=color:#e6db74>&#34;l&#34;</span>, from: &amp;word)
</span></span><span style=display:flex><span><span style=color:#75715e>// Expect: removed == 2, word == &#34;heo&#34;</span>
</span></span></code></pre></div></li></ul><p><strong>Hints (API):</strong></p><ul><li>Use <code>s.firstIndex(of: c)</code> to find the next index.</li><li>Use <code>s.remove(at: index)</code> to remove a character.</li><li>A <code>while let</code> loop is helpful here.</li></ul><hr><h4 id=e3--count-and-strip-spaces-with-inout-multi-result>E3 — Count and strip spaces with <code>inout</code> (multi-result)</h4><p><strong>Goal:</strong> Return one piece of information and also update the original string.</p><p>Write:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>countAndStripSpaces</span>(from text: <span style=color:#66d9ef>inout</span> String) -&gt; Int {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Requirements:</p><ul><li><p>Remove <strong>all spaces</strong> (<code>" "</code>) from <code>text</code>.</p></li><li><p>Return how many spaces were removed.</p></li><li><p>Example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>var</span> title = <span style=color:#e6db74>&#34;The  Well   Tempered   Clavier&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> removedSpaces = countAndStripSpaces(from: &amp;title)
</span></span><span style=display:flex><span><span style=color:#75715e>// Example result: removedSpaces == 6, title == &#34;TheWellTemperedClavier&#34;</span>
</span></span></code></pre></div></li></ul><p><strong>Hints (API):</strong></p><ul><li>One approach: loop while <code>text.contains(" ")</code> and use <code>firstIndex(of:)</code> + <code>remove(at:)</code>.</li><li>Another approach: build a new string with <code>filter { $0 != " " }</code>, then compare lengths.
You can still use <code>inout</code> by assigning back to <code>text</code>.</li></ul><hr><h4 id=e4--clamp-a-score-with-inout-safely-modify-numbers>E4 — Clamp a score with <code>inout</code> (safely modify numbers)</h4><p><strong>Goal:</strong> Use <code>inout</code> on a simple numeric value.</p><p>Write:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>clampScore</span>(<span style=color:#66d9ef>_</span> score: <span style=color:#66d9ef>inout</span> Int, min: Int = <span style=color:#ae81ff>0</span>, max: Int = <span style=color:#ae81ff>100</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Requirements:</p><ul><li><p>If <code>score</code> is less than <code>min</code>, set it to <code>min</code>.</p></li><li><p>If <code>score</code> is greater than <code>max</code>, set it to <code>max</code>.</p></li><li><p>Otherwise, leave it unchanged.</p></li><li><p>Test:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>var</span> exam = <span style=color:#f92672>-</span><span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>clampScore(&amp;exam)        <span style=color:#75715e>// exam should become 0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> bonus = <span style=color:#ae81ff>150</span>
</span></span><span style=display:flex><span>clampScore(&amp;bonus)       <span style=color:#75715e>// bonus should become 100</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> midterm = <span style=color:#ae81ff>88</span>
</span></span><span style=display:flex><span>clampScore(&amp;midterm)     <span style=color:#75715e>// stays 88</span>
</span></span></code></pre></div></li></ul><p><strong>Hints (API):</strong></p><ul><li>Use simple <code>if</code>/<code>else if</code> checks.</li><li>You can also use <code>score = max(min, min(score, max))</code> if that feels comfortable.</li></ul><hr><h4 id=e5--decompose-seconds-into-minutes-and-seconds-multiple-inout-parameters>E5 — Decompose seconds into minutes and seconds (multiple <code>inout</code> parameters)</h4><p><strong>Goal:</strong> Imitate a “multiple outputs” function using <code>inout</code>.</p><p>Write:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>decompose</span>(timeInSeconds: Int, minutes: <span style=color:#66d9ef>inout</span> Int, seconds: <span style=color:#66d9ef>inout</span> Int) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Requirements:</p><ul><li><p>Compute how many full minutes and leftover seconds are in <code>timeInSeconds</code>.</p></li><li><p>Store the results in <code>minutes</code> and <code>seconds</code>.</p></li><li><p>Example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>var</span> mins = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> secs = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>decompose(timeInSeconds: <span style=color:#ae81ff>125</span>, minutes: &amp;mins, seconds: &amp;secs)
</span></span><span style=display:flex><span><span style=color:#75715e>// mins == 2, secs == 5</span>
</span></span></code></pre></div></li></ul><p><strong>Hints (API):</strong></p><ul><li>Use integer division <code>/</code> to get minutes: <code>timeInSeconds / 60</code>.</li><li>Use remainder <code>%</code> to get leftover seconds: <code>timeInSeconds % 60</code>.</li></ul><hr><h4 id=e6--dog-rename-vs-reset-reference-type-vs-inout>E6 — Dog rename vs reset (reference type vs <code>inout</code>)</h4><p><strong>Goal:</strong> See the difference between mutating a property and replacing an object.</p><p>Start with:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Dog</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> name: String = <span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Tasks:</p><ol><li><p>Write a function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>rename</span>(<span style=color:#66d9ef>_</span> dog: Dog, to newName: String) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><p>This should set <code>dog.name</code> to <code>newName</code> without using <code>inout</code>.</p></li><li><p>Test:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>let</span> d = Dog()
</span></span><span style=display:flex><span>d.name = <span style=color:#e6db74>&#34;Fido&#34;</span>
</span></span><span style=display:flex><span>rename(d, to: <span style=color:#e6db74>&#34;Rover&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>// d.name should now be &#34;Rover&#34;</span>
</span></span></code></pre></div></li></ul></li><li><p>Write a second function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>resetDog</span>(<span style=color:#66d9ef>_</span> dog: <span style=color:#66d9ef>inout</span> Dog) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><p>This should <strong>replace</strong> the existing <code>Dog</code> with a new one named <code>"Default"</code>.</p></li><li><p>Test:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>var</span> myDog = Dog()
</span></span><span style=display:flex><span>myDog.name = <span style=color:#e6db74>&#34;Chopin&#34;</span>
</span></span><span style=display:flex><span>resetDog(&amp;myDog)
</span></span><span style=display:flex><span><span style=color:#75715e>// myDog.name should now be &#34;Default&#34;</span>
</span></span></code></pre></div></li></ul></li></ol><p><strong>Concept reflection:</strong></p><ul><li>In a short comment, explain why <code>rename(_:,to:)</code> didn’t need <code>inout</code>, but <code>resetDog(_:)</code> did.</li></ul></section></article></main><footer><footer><link rel=stylesheet href=/css/years.css></footer></body></html></footer></body></html>